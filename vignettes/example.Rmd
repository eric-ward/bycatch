---
title: "Bycatch Estimation and Expansion in STAN"
author: "Eric Ward"
date: "March 21, 2017"
output:
  pdf_document: default
  html_document: default
---

## Background

Following Martin et al. (2015), our models use a rate parameter $\theta$ representing the per set (or hook, or other metric observed) take rate. The take rate is combined with measures of effort $E_{t}$ (observed sets) to calculate the expected number of observed takes, $${ \lambda  }_{ i }=\theta E_{ t }$$. The observed takes are related to expected by assuming a Poisson distribution, $$Y_{t} \sim Poisson(\lambda_{t})$$. Covariates can be included in this framework in several ways. First, we can include a covariate matrix $X$ and estimate the effects of each covariate on $\theta$ using a log-link, $$log(\theta_{t}) = B_{0} + B_{1}*X_{t,1} + B_{2}*X_{t,2}$$. A second way to include covariates is as a random walk in time (analogous to a DLM, using the `time_varying=TRUE` argument). In this setting, each year has an estimated temporal deviation modeled as a random walk, 
$${ \delta  }_{ t }\sim Normal\left( { \delta  }_{ t-1 },\sigma  \right)$$ and these are incorporated into the bycatch rate as $$log(\theta_{t}) = B_{0} + B_{1}*X_{t,1} + \delta_{t}...$$.

This framework multiplies the estimated per set bycatch rate $\theta_{t}$ by the known effort $E_{t}$ to generate the mean bycatch in each year. This expectation represents the mean, as if this were an experiment, and multiple samples were generated repeatedly. In scenarios where observer coverage is 100%, no expansion is necessary, and these estimates will be used as the total expected bycatch. Because intervals around these estimates represent intervals around a mean, we don't expect the observed data to be contained 95% of the time (or any other threshold). *If we included an observation model on top of these estimates, we would generate intervals with these properties*

In situations where observer coverage is $0 < p < 1$, we need to extrapolate these estimates to the unobserved sets. One approach for doing this is to view each estimated number of takes (corrected for effort) $\lambda_{t}$ as the $x$ of a Binomial distribution with known $p$ (observer coverage is known) but unknown N. This algorithm works by iterating over MCMC draws ($i = 1, 2, ...,n$). For each draw and in each year, we can generate ${ N }_{ i,t }|p,{ x }_{ i,t }={ \lambda  }_{ i,t }$. because the relative probabilities of each ${ N }_{ i,t }$ can be computed using `dbinom(x = x, size = N, prob = p)`. 

In terms of interpretation, the only constraints on ${ N }_{ i,t }$ are that they have to be greater than ${ x }_{ i,t }$. Like the ${ x }_{ i,t }$, the ${ N }_{ i,t }$ represents the expanded mean (and thus, the 95% CIs are not expected to contain most of the observations). 

## Load library

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, results="hide", message=FALSE, warning=FALSE}
require(devtools)
devtools::install_github("eric-ward/bycatch")
library(bycatch)
```

## Load data
```{r data}
# replace this with your own data frame
d = data.frame("Year"= 2002:2014, 
  "Takes" = c(0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0),
  "expansionRate" = c(24, 22, 14, 32, 28, 25, 30,  7, 26, 21, 22, 23, 27),
  "Sets" = c(391, 340, 330, 660, 470, 500, 330, 287, 756, 673, 532, 351, 486))
```

## Fit model

```{r, results="hide", message=FALSE, warning=FALSE}
fit = bycatch_expansion(time = d[,"Year"], events = d[,"Takes"], 
  effort = d[,"Sets"], coverage = d[,"expansionRate"])
```

## Make plots

```{r, fig.pos="placeHere", fig.cap = "Estimated fleet-level bycatch (not expanded by observer coverage), incorporating data on takes, effort. Dots represent observed bycatch events."}
plot_fitted(fit, xlab="Year", ylab = "Fleet-level bycatch")
```
  
  
```{r, fig.pos="placeHere", fig.cap = "Estimated fleet-level expanded bycatch, incorporating data on takes, effort, and observer coverage. Dots represent observed bycatch events."}
plot_expanded(fit, xlab="Year", ylab = "Fleet-level bycatch")
```

  
## Make table of expanded bycatch estimates

```{r, eval=FALSE}
df = data.frame("time" = d[,"Year"], 
  "mean" = apply(fit$expanded_estimates, 2, mean),
  "median" = apply(fit$expanded_estimates, 2, quantile, 0.5),
  "lower95" = apply(fit$expanded_estimates, 2, quantile, 0.025),
  "upper95" = apply(fit$expanded_estimates, 2, quantile, 0.975))

write.table(df, "estimated_bycatch.csv", row.names=F, col.names=T, sep=",")
```

\break 

## Example with covariates

Following [Martin et al. 2015](http://onlinelibrary.wiley.com/doi/10.1890/14-0059.1/abstract) we can include fixed or continuous covariates. This needs to be passed in as a design matrix, so using `model.matrix()` is one easy way to do this. 

For example, to add a continuous and indictor covariate to the example above, we can pass in the matrix `covar`,

```{r}
covar = cbind(1, rnorm(nrow(d)), c(rep(0,5), rep(1, nrow(d)-5)))
colnames(covar) = c("intercept","predictor","factor")
print(covar)
```

```{r eval=FALSE}
fit = bycatch_expansion(time = d[,"Year"], events = d[,"Takes"], 
  effort = d[,"Sets"], coverage = d[,"expansionRate"], covar = covar)
```

\break 

## Fit model with time-varying effects

To incorporate potential autocorrelation, we can fit a model with time-varying random effects. This is equivalent to a dynamic linear model with time varying intercept in a Poisson GLM. 

```{r, results="hide", message=FALSE, warning=FALSE}
fit = bycatch_expansion(time = d[,"Year"], events = d[,"Takes"], 
  effort = d[,"Sets"], coverage = d[,"expansionRate"], time_varying=TRUE)
```

```{r, fig.pos="placeHere", fig.cap = "Estimated fleet-level expanded bycatch from the model with time-varying effects, incorporating data on takes, effort, and observer coverage. Dots represent observed bycatch events."}
plot_expanded(fit, xlab="Year", ylab = "Fleet-level bycatch")
```
